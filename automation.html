<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Automation Notes</title>
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      margin: 0;
      padding: 2rem;
      background-color: #f9f9f9;
      color: #333;
      max-width: 900px;
      margin: auto;
    }
    h1 {
      color: #0d47a1;
      text-align: center;
    }
    details {
      margin: 1rem 0;
      padding: 1rem;
      border: 1px solid #ccc;
      border-radius: 8px;
      background-color: #fff;
    }
    summary {
      font-weight: bold;
      font-size: 1.1rem;
      cursor: pointer;
    }
    code {
      background-color: #eee;
      padding: 2px 6px;
      border-radius: 4px;
    }
    pre {
      background-color: #eee;
      padding: 1rem;
      border-radius: 4px;
      overflow-x: auto;
    }
  </style>
</head>
<body>
  <h1>üß™ Automation Notes</h1>
  <a href="index.html">‚Üê Back to Home</a>

  <details>
    <summary>üîç XPath: Complete Guide</summary>

    <details>
      <summary>üìå What is XPath?</summary>
      <p>XPath (XML Path Language) is used to locate elements in an XML or HTML document. In automation tools like Selenium, XPath helps you find and interact with web elements.</p>
    </details>

    <details>
      <summary>üõ†Ô∏è How to Write XPath (with Examples)</summary>
      <ul>
        <li><strong>By tag name:</strong> <code>//input</code></li>
        <li><strong>By attribute:</strong> <code>//input[@type='text']</code></li>
        <li><strong>By multiple attributes:</strong> <code>//input[@type='text' and @name='username']</code></li>
        <li><strong>By text:</strong> <code>//button[text()='Submit']</code></li>
        <li><strong>By partial text:</strong> <code>//a[contains(text(),'Login')]</code></li>
        <li><strong>Using functions:</strong> <code>//input[starts-with(@id, 'user')]</code></li>
      </ul>
    </details>

    <details>
      <summary>üîÑ What Are XPath Axes? (with Examples)</summary>
      <p>XPath axes let you navigate through related elements in the DOM relative to the current node.</p>
      <ul>
        <li><strong>child::</strong> ‚Äì Direct children<br><code>//div/child::p</code></li>
        <li><strong>parent::</strong> ‚Äì Immediate parent<br><code>//label/parent::div</code></li>
        <li><strong>ancestor::</strong> ‚Äì All ancestors<br><code>//span/ancestor::div</code></li>
        <li><strong>descendant::</strong> ‚Äì All descendants<br><code>//div/descendant::a</code></li>
        <li><strong>following::</strong> ‚Äì All elements after the node<br><code>//h2/following::div</code></li>
        <li><strong>preceding::</strong> ‚Äì All elements before the node<br><code>//h2/preceding::div</code></li>
        <li><strong>following-sibling::</strong> ‚Äì Next siblings<br><code>//label/following-sibling::input</code></li>
        <li><strong>preceding-sibling::</strong> ‚Äì Previous siblings<br><code>//input/preceding-sibling::label</code></li>
        <li><strong>self::</strong> ‚Äì The node itself<br><code>//button/self::button</code></li>
      </ul>
    </details>

    <details>
      <summary>üìà When to Use XPath Axes?</summary>
      <ul>
        <li>‚úÖ When the element has no unique attribute but is near a known element</li>
        <li>‚úÖ When you want to navigate to parents, children, or siblings</li>
        <li>‚úÖ Useful in dynamic web apps where IDs/classes change</li>
        <li>‚úÖ Ideal for table rows, forms, and nested structures</li>
      </ul>
      <p><strong>Example:</strong><br>If you want the input that comes after a label "Username":<br>
      <code>//label[text()='Username']/following-sibling::input</code></p>
    </details>

    <details>
      <summary>üí° Bonus: Absolute vs Relative XPath</summary>
      <ul>
        <li><strong>Absolute:</strong> Starts from root (fragile)<br><code>/html/body/div[1]/input</code></li>
        <li><strong>Relative:</strong> Starts from anywhere (preferred)<br><code>//input[@id='email']</code></li>
      </ul>
    </details>

  <details>
    <summary>ü§ñ Automation + Technical Interview Questions</summary>
    <ul>
      <li><strong>1. Implicit vs Explicit waits:</strong> Implicit waits globally; Explicit waits wait for specific condition.</li>
      <li><strong>2. XPath live:</strong> Use browser DevTools ‚Üí Inspect element ‚Üí Right-click ‚Üí Copy XPath.</li>
      <li><strong>3. Actions/Select:</strong> Actions = mouse/keyboard simulation; Select = handle dropdowns.</li>
      <li><strong>4. Roles:</strong> Writing scripts, maintaining framework, integrating CI/CD.</li>
      <li><strong>5. Selenium Exceptions:</strong> NoSuchElement, Timeout, StaleElement, ElementNotInteractable, WebDriverException.</li>
      <li><strong>6. OOPs Concepts:</strong> Inheritance, Polymorphism, Encapsulation, Abstraction.</li>
      <li><strong>7. findElement vs findElements:</strong> One returns first match; Other returns list.</li>
      <li><strong>8. Handle Alerts:</strong> <code>driver.switchTo().alert()</code> for accept/dismiss.</li>
      <li><strong>9. Screenshot code:</strong> <code>TakesScreenshot ts = (TakesScreenshot) driver; File src = ts.getScreenshotAs(OutputType.FILE);</code></li>
      <li><strong>10. TestNG priority:</strong> Lower number = higher priority.</li>
      <li><strong>11. Reports:</strong> Extent Reports, Allure, TestNG default.</li>
      <li><strong>12. Cucumber Scenario vs Outline:</strong> Outline = used for data-driven; Scenario = fixed data.</li>
      <li><strong>13. Framework:</strong> Hybrid (POM + Data Driven + Modular).</li>
      <li><strong>14. Tags in Cucumber:</strong> Used to filter which tests to run.</li>
      <li><strong>15. Test data mgmt:</strong> Excel, JSON, DB, Faker libraries.</li>
      <li><strong>16. Abstract vs Interface:</strong> Interface = fully abstract; Abstract class = partial implementation.</li>
      <li><strong>17. Reverse String:</strong> <code>new StringBuilder(str).reverse().toString();</code></li>
      <li><strong>18. HashMap vs HashSet:</strong> Map = key-value; Set = unique values.</li>
      <li><strong>19. Array vs ArrayList:</strong> Array = fixed size; ArrayList = dynamic.</li>
      <li><strong>20. Collection:</strong> Root interface of data structures like List, Set.</li>
      <li><strong>21. String immutable:</strong> Security, performance (string pool).</li>
      <li><strong>22. Collection vs Collections:</strong> Interface vs Utility class.</li>
      <li><strong>23. StringBuffer vs StringBuilder:</strong> Buffer = thread-safe; Builder = faster (non-thread-safe).</li>
      <li><strong>24. API Status Codes:</strong> 200 = OK, 201 = Created, 400 = Bad Request, 401 = Unauthorized.</li>
      <li><strong>25. PUT vs PATCH:</strong> PUT = full update; PATCH = partial update.</li>
      <li><strong>26. Git commands:</strong> <code>git init, git add, git commit, git push, git diff, git log</code></li>
    </ul>
  </details>

  </details>

</body>
</html>
