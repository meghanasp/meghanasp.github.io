<!-- selenium.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>QA Notes</title>
  <style>
  details {
    background: #f9f9f9;
    border: 1px solid #ccc;
    border-radius: 6px;
    padding: 10px;
    margin: 1rem 0;
  }
  summary {
    font-weight: bold;
    cursor: pointer;
    font-size: 1.05rem;
  }
  summary:hover {
    color: #0d47a1;
  }
</style>
</head>
<body>
  <h1>ğŸ§ª QA Automation Notes</h1>
  
  <section id="qa-terms">
  <h2>ğŸ“˜ Terms Every QA Professional Must Know!</h2>
  <p>If you're in QA, you should definitely know these essential terms.<br>
     They help you test better, communicate smarter, and think like a true Quality Engineer.</p>

  <details>
    <summary>ğŸ”¹ 1â€“5: Core Testing Terms</summary>
    <ul>
      <li><strong>Test Scenario</strong> â€“ High-level condition to be tested</li>
      <li><strong>Test Case</strong> â€“ Step-by-step instructions to verify functionality</li>
      <li><strong>Test Suite</strong> â€“ Group of test cases for a module</li>
      <li><strong>Test Data</strong> â€“ Input values used during testing</li>
      <li><strong>Test Plan</strong> â€“ Strategy, scope, and schedule of testing</li>
    </ul>
  </details>

  <details>
    <summary>ğŸ”¹ 6â€“10: Requirements & Smoke Testing</summary>
    <ul>
      <li><strong>RTM</strong> â€“ Mapping of requirements to test cases</li>
      <li><strong>Functional Testing</strong> â€“ Validates expected functionality</li>
      <li><strong>Non-Functional Testing</strong> â€“ Checks performance, security, usability</li>
      <li><strong>Exploratory Testing</strong> â€“ Learning + testing without scripts</li>
      <li><strong>Smoke Testing</strong> â€“ Basic build verification</li>
    </ul>
  </details>

  <details>
    <summary>ğŸ”¹ 11â€“15: Testing Types & Defects</summary>
    <ul>
      <li><strong>Sanity Testing</strong> â€“ Quick checks for specific areas</li>
      <li><strong>Regression Testing</strong> â€“ Ensure new code doesnâ€™t break existing features</li>
      <li><strong>Retesting</strong> â€“ Testing failed test cases after bug fix</li>
      <li><strong>Defect Life Cycle</strong> â€“ Bug journey from open to close</li>
      <li><strong>Severity</strong> â€“ Impact of a defect on the system</li>
    </ul>
  </details>

  <details>
    <summary>ğŸ”¹ 16â€“20: Defect Management & Validation</summary>
    <ul>
      <li><strong>Priority</strong> â€“ Urgency of fixing the defect</li>
      <li><strong>BVA</strong> â€“ Testing at input boundaries</li>
      <li><strong>EP</strong> â€“ Grouping inputs into valid/invalid sets</li>
      <li><strong>UAT</strong> â€“ End-user validation of requirements</li>
      <li><strong>QA</strong> â€“ Process to prevent defects</li>
    </ul>
  </details>

  <details>
    <summary>ğŸ”¹ 21â€“25: Quality, Automation, DevOps</summary>
    <ul>
      <li><strong>QC</strong> â€“ Finding defects in the product</li>
      <li><strong>Bug Leakage</strong> â€“ Bugs missed in testing, found later</li>
      <li><strong>Bug Release</strong> â€“ Known bugs released intentionally</li>
      <li><strong>Automation Testing</strong> â€“ Using tools to auto-execute tests</li>
      <li><strong>CI/CD</strong> â€“ Automated integration and deployment</li>
    </ul>
  </details>

  <details>
    <summary>ğŸ”¹ 26â€“30: Assertions, API, Performance, E2E</summary>
    <ul>
      <li><strong>Assertions</strong> â€“ Validating expected vs actual result</li>
      <li><strong>API Testing</strong> â€“ Testing backend using tools like Postman</li>
      <li><strong>Load Testing</strong> â€“ Testing under expected user load</li>
      <li><strong>Integration Testing</strong> â€“ Checking interaction between modules</li>
      <li><strong>E2E Testing</strong> â€“ Verifying complete user flow</li>
    </ul>
  </details>

  <details>
    <summary>ğŸ“‹ Manual Testing Interview Questions</summary>
    <ul>
      <li><strong>1. Agile methodology:</strong> Yes, Iâ€™ve worked in Agile. It involves iterative development, daily stand-ups, sprints, backlog grooming, and reviews.</li>
      <li><strong>2. Writing test cases:</strong> Include clear steps, expected results, valid data, boundary values, and ensure they are reusable and maintainable.</li>
      <li><strong>3. Bug Life Cycle:</strong> New â†’ Assigned â†’ Open â†’ Fixed â†’ Retest â†’ Verified â†’ Closed (or Reopen/Rejected if needed).</li>
      <li><strong>4. Scenario vs Test Case:</strong> Scenario = High-level idea; Test Case = Step-by-step execution.</li>
      <li><strong>5. Functional vs Non-Functional:</strong> Functional checks features; Non-functional tests performance, security, etc.</li>
      <li><strong>6. Smoke vs Sanity:</strong> Smoke = basic build check; Sanity = targeted check after a fix.</li>
      <li><strong>7. STLC:</strong> Phases from Requirement Analysis â†’ Test Planning â†’ Test Design â†’ Execution â†’ Closure.</li>
      <li><strong>8. Alpha vs Beta:</strong> Alpha = in-house testing; Beta = real users before release.</li>
      <li><strong>9. Tests per sprint:</strong> Depends on complexity, usually 20â€“40 cases.</li>
      <li><strong>10. Automate test selection:</strong> Choose high ROI, repeatable, stable tests.</li>
      <li><strong>11. Do not automate:</strong> Exploratory, ad-hoc, or unstable UI tests.</li>
      <li><strong>12. 100% automation:</strong> Not practical or recommended.</li>
      <li><strong>13. Logging bugs:</strong> Include steps, environment, expected vs actual result, screenshots/logs.</li>
      <li><strong>14. Test case tools:</strong> Excel, TestRail, Zephyr, XRay.</li>
    </ul>
  </details>
</section>
  
  <a href="index.html">â† Back to Home</a>
</body>
</html>
